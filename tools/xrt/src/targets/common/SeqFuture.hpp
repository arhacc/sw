///
/// \file SeqFuture.hpp
///
/// \brief Definition of class SeqFuture.
#pragma once

#include <targets/common/Future.hpp>

#include <functional>
#include <vector>

///
/// \breif Represents a full sequence of IO operations where the order is guaranteed.
///
/// This class will keep calling the provided Sequencer in order to obtain futures until it returns a nullptr. At that
/// point it will be considered done.
///
/// This future is meant to be used when future A must be started only after future B and this can effect would not
/// generally be guaranteed. AndFuture is to be preferred otherwise, because of it's lower overhead. In particular, when
/// creating multiple transactions on the same channel (for example, multiple register writes) the channel will
/// guarantee the order.
///
/// This future must be waited on in order to resolve.
class SeqFuture final : public Future {
  public:
    ///
    /// \brief Abstract class representing a generator of a sequence of futures for SeqFuture.
    class Sequencer {
      public:
        virtual ~Sequencer();

        ///
        /// \brief Returns the next future in the sequence.
        ///
        /// This function will be called to obtain the next future in the sequence. It is guaranteed that this function
        /// will only be called after the previous future is done.
        ///
        /// When the sequence is over, this function should return nullptr.
        ///
        /// \return The next future in the sequence.
        virtual std::shared_ptr<Future> next() = 0;
    };

    ///
    /// \brief A generator of a sequence of futures for SeqFuture, each future generated by a function/lambda.
    ///
    /// Each function will only be called once, and only after the previous function's future is done.
    class SimpleSequencer final : public Sequencer {
      public:
        typedef std::function<std::shared_ptr<Future>()> Function;

      private:
        std::vector<Function> functions_;
        std::size_t i_{0};

      public:
        ///
        /// \brief Construct the sequencer from a vector of functions.
        ///
        /// \param functions The list of functions, each generating a future.
        explicit SimpleSequencer(std::vector<Function>&& functions);
        ~SimpleSequencer() override;

        SimpleSequencer(const SimpleSequencer& simpleSequencer) = delete;
        SimpleSequencer(SimpleSequencer&& simpleSequencer) noexcept;
        auto operator=(const SimpleSequencer& simpleSequencer) -> SimpleSequencer& = delete;
        auto operator=(SimpleSequencer&& simpleSequencer) noexcept -> SimpleSequencer&;

        ///
        /// \brief Returns the next future in the sequence.
        ///
        /// The next function in the list is called, and it's returned future is returned. If there are no more
        /// functions in the list, nullptr is returned.
        ///
        /// \return The next future in the sequence.
        auto next() -> std::shared_ptr<Future> override;
    };

  private:
    std::unique_ptr<Sequencer> sequencer_;
    std::shared_ptr<Future> currentFuture_;

  public:
    ///
    /// \brief Generate a SeqFuture with the provided sequencer.
    explicit SeqFuture(std::unique_ptr<Sequencer> sequencer);

    ///
    /// \brief Wait until all the futures in the sequence are done.
    ///
    /// One of the wait functions must be called in order for this future to resolve.
    auto wait() -> void override;

    ///
    /// \brief Wait until all the futures in the sequence are done, or the specified timeout to expire.
    ///
    /// One of the wait functions must be called in order for this future to resolve.
    ///
    /// \param d The timeout to wait for.
    /// \return True if all the futures finished, false if the timeout expired.
    auto wait(std::chrono::nanoseconds d) -> bool override;

    ///
    /// \brief Reports if all the futures in the sequence are done.
    ///
    /// One of the wait functions must be called in order for this future to resolve.
    ///
    /// \return True if all the futures finished, false otherwise.
    [[nodiscard]] auto isDone() const -> bool override;
};
